
# Concept

Goal: Telemetry operator should be extended to a kind of automatic templating to be used in combination with the ServiceCatalog.


The original workflow for a user creating a ServiceBinding remains unchanged, which keeps the user workflow easier. There is no advantage of changing the user workflow. We also thought of changing the workflow to have a more automated setup, but this would require more knowledge of the user to actually perform the ServiceBinding with the automated FluentBit Configuration.
Instead, the workflow will be expanded by one additional step to create the FluentBit configuration for the corresponding ServiceBinding.

This concept covers the basic requirements with a minimal setup and reusing the Telemetry Operator for this purpose. At a later point, the Telemetry Operator could be split up to have a cleaner operator architecture, but this needs to be discussed further in the future.


## General Architecture / Workflow:

The following Workflow is explained in the context of the BTP Operator's ServiceBinding. The user can also refer to a Secret which is created by another instance or by the user. In this case, step one and two are skipped, and in step three the user refers to a custom Secret.

1. User creates ServiceBinding using CLI, BTP, or Busola.
2. BTP Operator watches ServiceBinding-CRs and creates corresponding Secret.
3. User creates PresetBinding-CR and references to the Secret created by the BTP Operator. Furthermore, the user must specify which Preset should be used.
4. Telemetry Operator watches PresetBinding-CRs. If a new CR is created, Telemetry Operator creates a new LogPipeline-CR, using the Preset and the information given by the referenced Secret.
5. Telemetry operator creates new FluentBitConfig based on LogPipeline-CR.

![Workflow Architecture](images/workflow-overview.svg)

## Templating

To map the key-value pairs given by the referenced Secret, we need a CRD that maps the keys of the Secret to the corresponding FluentBit Output keys. Thus, the `Preset`-CRD is needed. This CRD is defined by:
- Name
- Mapping from Secret keys to FluentBit keys
- The filter, parser, and output plugins of FluentBit that are to be used
- Configuration of these filters and outputs

Kyma will then have predefined Preset-CRs, which the customer can use to create a FluentBit configuration based on the customer's created ServiceBinding. In this way, the users does not have to care about maintaining filters (i.e. `Lua` scripts), configuration of outputs (i.e. `http`-Plugin), etc.


## Secret Rotation

In this concept, the user refers to the Secret created by the BTP Operator, which is then mounted by the Telemetry Operator in the corresponding container. Therefore, the Secret rotation happens automatically by the general function of the Telemetry Operator.

> **NOTE:** The Secret rotation is not implemented in the Telemetry Operator until now (as of today; 15.10.2021).


# Extensibility for OpenTelemetry Collector Instances

The shown concept should be future-proof to be used for a controller or operator that manages OpenTelemetry Collector as well.
Even though a controller for the OpenTelemetry Collector is not part of Kyma yet, its CRD would have to meet the following requirement. This is necessary to separate the configuration's structure from specific settings that must be provided by Kubernetes Secrets.

## OpenTelemetry Collector CRD Requirements

In contrary to the FluentBit pipelines, where stages are connected by labels, the OpenTelemetry Collector configuration contains explicit pipeline descriptions.
These pipeline descriptions connect Receivers, Processors and Exporters.
This design does not allow to modify the configuration by appending raw snippets as the Telemetry Operator does for the LogPipeline CRD.

It is a requirement for the future use of OpenTelemetry Collectors that the pipelines can be extended by the user.
In particular, this includes adding new Exporters to a predefined pipeline.
A future OpenTelemetry Collector API / CRD should allow inputs of Receivers, Processors and Exporters by the user.
The resulting service and pipeline definition is generated by the controller in the next step.
To fulfill the minimal requirement to adapt the templating mechanism for service consumption, this CRD is defined so that again, the user can paste the raw configuration section, which might reference Secrets.

The upstream [OpenTelemetry Operator](https://github.com/open-telemetry/opentelemetry-operator) only accepts complete Collector configurations and thus, does not allow to specify extensible pipelines.

A later CRD for the OpenTelemetry Collector as part of the operator might look as follows:

- The operator uses different CRDs for tracing and metrics (`TracePipeline` and `MetricPipeline`).
- Pipelines for the OpenTelemetry Collector service are generated by the operator from these CRDs.
- Users can define processors and exporters in their custom resources and reference secrets. Receivers are not intended to be modified by users.

This example describes a `TracePipeline` for a Zipkin exporter:

```YAML
kind: TracePipeline
metadata:
  name: tracing-zipkin
spec:
    processors:
      attributes/meta:
        actions:
        - key: environment
            value: production
            action: insert
    exporters:
      zipkin/bla:
        endpoint: http://${HOST}:9411/api/v2/spans # ${HOST} is consumed from the Secret
        insecure: true
    secretRefs:
    - name: zipkin-credentials
      namespace: default
```

## Example

A commercial provider might offer an ElasticSearch-based service that can receive logs using the ElasticSearch protocol. Kyma might contain a preset for this `ElasticService` that contains all necessary configurations.

```YAML
kind: LogPreset
apiVersion: telemetry.kyma-project.io/v1alpha1
metadata:
  name: ElasticService
spec:
  parsers: {}
  multilineParsers:
    - content: |
        # Example from https://docs.fluentbit.io/manual/pipeline/filters/multiline-stacktrace
        name          multiline-custom-regex
        type          regex
        flush_timeout 1000
        rule      "start_state"   "/(Dec \d+ \d+\:\d+\:\d+)(.*)/"  "cont"
        rule      "cont"          "/^\s+at.*/"                     "cont"
  filters:
    - content: |
        name                  multiline
        match                 *
        multiline.key_content log
        multiline.parser      go, multiline-custom-regex
    - content: |
        Name    record_modifier
        Match   *
        Record  cluster_identifier ${KUBERNETES_SERVICE_HOST}
  outputs:
    - content: |
        Name               es
        Alias              es-output
        Match              *
        Host               ${ES_ENDPOINT} # Defined in Secret
        HTTP_User          ${ES_USER} # Defined in Secret
        HTTP_Password      ${ES_PASSWORD} # Defined in Secret
        LabelMapPath       /files/labelmap.json
  files:
    - name: labelmap.json
      content: |
      {
          "kubernetes": {
            "namespace_name": "namespace",
            "pod_name": "pod"
          },
          "stream": "stream"
      }
  placeholders:
    - name: ES_ENDPOINT
      description: endpoint URL
    - name: ES_USER
      description: Elastic user
      default: admin
    - name: ES_PASSWORD
      description: Elastic password
    - name: KUBERNETES_SERVICE_HOST
      description: Cluster identifier
```

1. The user creates a Kubernetes Secret with their credentials and service endpoint. This can happen either manually or by creating a ServiceBinding:

```YAML
apiVersion: v1
kind: Secret
metadata:
  name: my-elastic-credentials
  namespace: default
type: Opaque
data:
  ES_ENDPOINT: aG9zdAo=
  ES_USER: Zm9vCg==
  ES_PASSWORD: YmFyCg==
```

2. The user creates a `LogPresetBinding` CR that indicates the usage of their Secret for the `ElasticService`. Values that are not provided by the Secret can be configured explicitly in the bindings section. The operator will try to attempt an automatic binding for all other placeholders:

```YAML
kind: LogPresetBinding
apiVersion: telemetry.kyma-project.io/v1alpha1
metadata:
  name: ElasticService
spec:
  presetRef: ElasticService
  secretRef:
    - name: my-elastic-credentials
      namespace: default
  bindings:
    - placeholder: KUBERNETES_SERVICE_HOST
      staticValue: cluster-123
  selector:
    excludeSystemNamespaces: true
    namespaces: {}
    matchLabels:
      app: my-deployment
```

3. The Telemetry Operator generates the low-level CRs based on the preset and the secret. The filters section is enhanced by filters that are generated from the selectors of the LogPresetBinding:

```YAML
kind: LogPipeline
apiVersion: telemetry.kyma-project.io/v1alpha1
metadata:
  name: ElasticService-instanceXYZ
spec:
  parsers: {}
  multilineParsers:
    - content: |
        # Example from https://docs.fluentbit.io/manual/pipeline/filters/multiline-stacktrace
        name          multiline-custom-regex
        type          regex
        flush_timeout 1000
        rule      "start_state"   "/(Dec \d+ \d+\:\d+\:\d+)(.*)/"  "cont"
        rule      "cont"          "/^\s+at.*/"                     "cont"
  filters:
    - content: |
        name                  multiline
        match                 *
        multiline.key_content log
        multiline.parser      go, multiline-custom-regex
    - content: |
        # Generated from selector in LogPresetBinding
        Name    grep
        Match   *
        Regex   $kubernetes['labels']['app'] my-deployment
    - content: |
        # Generated from selector excludeSystemNamespaces property in LogPresetBinding
        Name    grep
        Match   *
        Exclude $kubernetes['namespace_name'] kyma-system|kube-system|kyma-integration|istio-system
    - content: |
        Name    record_modifier
        Match   *
        Record  cluster_identifier ${KUBERNETES_SERVICE_HOST}
  outputs:
    - content: |
        Name               es
        Alias              es-output
        Match              *
        Host               ${ES_ENDPOINT} # Defined in Secret
        HTTP_User          ${ES_USER} # Defined in Secret
        HTTP_Password      ${ES_PASSWORD} # Defined in Secret
        LabelMapPath       /files/labelmap.json
  files:
    - name: labelmap.json
      content: |
      {
          "kubernetes": {
            "namespace_name": "namespace",
            "pod_name": "pod"
          },
          "stream": "stream"
      }
  secretRefs:
    - name: my-elastic-credentials
      namespace: default
    - name: ElasticService-static # Created by the Telemetry Operator to store static values from the LogPresetBinding
      namespace: default
```

> **_NOTE:_**   The example should primarily demonstrate the concept for the CRD and might not be semantically correct in all aspects.